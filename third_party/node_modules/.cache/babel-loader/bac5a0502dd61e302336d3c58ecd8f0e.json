{"ast":null,"code":"/*\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport THREE from './third_party/three.js'; // remaps opacity from 0 to 1\n\nconst opacityRemap = mat => {\n  if (mat.opacity === 0) {\n    mat.opacity = 1;\n  }\n};\n/**\n * The Reticle class creates an object that repeatedly calls\n * `xrSession.requestHitTest()` to render a ring along a found\n * horizontal surface.\n */\n\n\nclass Reticle extends THREE.Object3D {\n  /**\n   * @param {XRSession} xrSession\n   * @param {THREE.Camera} camera\n   */\n  constructor(xrSession, camera) {\n    super();\n    this.loader = new THREE.TextureLoader();\n    let geometry = new THREE.RingGeometry(0.1, 0.11, 24, 1);\n    let material = new THREE.MeshBasicMaterial({\n      color: 0xffffff\n    }); // Orient the geometry so its position is flat on a horizontal surface\n\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(-90)));\n    this.ring = new THREE.Mesh(geometry, material);\n    geometry = new THREE.PlaneBufferGeometry(0.15, 0.15); // Orient the geometry so its position is flat on a horizontal surface,\n    // as well as rotate the image so the anchor is facing the user\n\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(-90)));\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(0)));\n    material = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 0\n    });\n    this.icon = new THREE.Mesh(geometry, material); // Load the anchor texture and apply it to our material\n    // once loaded\n\n    this.loader.load('../assets/Anchor.png', texture => {\n      this.icon.material.opacity = 1;\n      this.icon.material.map = texture;\n    });\n    this.add(this.ring);\n    this.add(this.icon);\n    this.session = xrSession;\n    this.visible = false;\n    this.camera = camera;\n  }\n  /**\n   * Fires a hit test in the middle of the screen and places the reticle\n   * upon the surface if found.\n   *\n   * @param {XRCoordinateSystem} frameOfRef\n   */\n\n\n  async update(frameOfRef) {\n    this.raycaster = this.raycaster || new THREE.Raycaster();\n    this.raycaster.setFromCamera({\n      x: 0,\n      y: 0\n    }, this.camera);\n    const ray = this.raycaster.ray;\n    const origin = new Float32Array(ray.origin.toArray());\n    const direction = new Float32Array(ray.direction.toArray());\n    const hits = await this.session.requestHitTest(origin, direction, frameOfRef);\n\n    if (hits.length) {\n      const hit = hits[0];\n      const hitMatrix = new THREE.Matrix4().fromArray(hit.hitMatrix); // Now apply the position from the hitMatrix onto our model\n\n      this.position.setFromMatrixPosition(hitMatrix);\n      DemoUtils.lookAtOnY(this, this.camera);\n      this.visible = true;\n    }\n  }\n\n}\n\nwindow.DemoUtils = {\n  /**\n   * Creates a THREE.Scene containing lights that case shadows,\n   * and a mesh that will receive shadows.\n   *\n   * @return {THREE.Scene}\n   */\n  createLitScene() {\n    const scene = new THREE.Scene(); // The materials will render as a black mesh\n    // without lights in our scenes. Let's add an ambient light\n    // so our material can be visible, as well as a directional light\n    // for the shadow.\n\n    const light = new THREE.AmbientLight(0xffffff, 1);\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);\n    directionalLight.position.set(10, 15, 10); // We want this light to cast shadow.\n\n    directionalLight.castShadow = true; // Make a large plane to receive our shadows\n\n    const planeGeometry = new THREE.PlaneGeometry(2000, 2000); // Rotate our plane to be parallel to the floor\n\n    planeGeometry.rotateX(-Math.PI / 2); // Create a mesh with a shadow material, resulting in a mesh\n    // that only renders shadows once we flip the `receiveShadow` property.\n\n    const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({\n      color: 0x111111,\n      opacity: 0.2\n    })); // Give it a name so we can reference it later, and set `receiveShadow`\n    // to true so that it can render our model's shadow.\n\n    shadowMesh.name = 'shadowMesh';\n    shadowMesh.receiveShadow = true;\n    shadowMesh.position.y = 10000; // Add lights and shadow material to scene.\n\n    scene.add(shadowMesh);\n    scene.add(light);\n    scene.add(directionalLight);\n    return scene;\n  },\n\n  /**\n   * Creates a THREE.Scene containing cubes all over the scene.\n   *\n   * @return {THREE.Scene}\n   */\n  createCubeScene() {\n    const scene = new THREE.Scene();\n    const materials = [new THREE.MeshBasicMaterial({\n      color: 0xff0000\n    }), new THREE.MeshBasicMaterial({\n      color: 0x0000ff\n    }), new THREE.MeshBasicMaterial({\n      color: 0x00ff00\n    }), new THREE.MeshBasicMaterial({\n      color: 0xff00ff\n    }), new THREE.MeshBasicMaterial({\n      color: 0x00ffff\n    }), new THREE.MeshBasicMaterial({\n      color: 0xffff00\n    })];\n    const ROW_COUNT = 4;\n    const SPREAD = 1;\n    const HALF = ROW_COUNT / 2;\n\n    for (let i = 0; i < ROW_COUNT; i++) {\n      for (let j = 0; j < ROW_COUNT; j++) {\n        for (let k = 0; k < ROW_COUNT; k++) {\n          const box = new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), materials);\n          box.position.set(i - HALF, j - HALF, k - HALF);\n          box.position.multiplyScalar(SPREAD);\n          scene.add(box);\n        }\n      }\n    }\n\n    return scene;\n  },\n\n  /**\n   * Loads an OBJ model with an MTL material applied.\n   * Returns a THREE.Group object containing the mesh.\n   *\n   * @param {string} objURL\n   * @param {string} mtlURL\n   * @return {Promise<THREE.Group>}\n   */\n  loadModel(objURL, mtlURL) {\n    // OBJLoader and MTLLoader are not a part of three.js core, and\n    // must be included as separate scripts.\n    const objLoader = new THREE.OBJLoader();\n    const mtlLoader = new THREE.MTLLoader(); // Set texture path so that the loader knows where to find\n    // linked resources\n\n    mtlLoader.setTexturePath(mtlURL.substr(0, mtlURL.lastIndexOf('/') + 1)); // remaps ka, kd, & ks values of 0,0,0 -> 1,1,1, models from\n    // Poly benefit due to how they were encoded.\n\n    mtlLoader.setMaterialOptions({\n      ignoreZeroRGBs: true\n    }); // OBJLoader and MTLLoader provide callback interfaces; let's\n    // return a Promise and resolve or reject based off of the asset\n    // downloading.\n\n    return new Promise((resolve, reject) => {\n      mtlLoader.load(mtlURL, materialCreator => {\n        // We have our material package parsed from the .mtl file.\n        // Be sure to preload it.\n        materialCreator.preload(); // Remap opacity values in the material to 1 if they're set as\n        // 0; this is another peculiarity of Poly models and some\n        // MTL materials.\n\n        for (let material of Object.values(materialCreator.materials)) {\n          opacityRemap(material);\n        } // Give our OBJ loader our materials to apply it properly to the model\n\n\n        objLoader.setMaterials(materialCreator); // Finally load our OBJ, and resolve the promise once found.\n\n        objLoader.load(objURL, resolve, function () {}, reject);\n      }, function () {}, reject);\n    });\n  },\n\n  /**\n   * Similar to THREE.Object3D's `lookAt` function, except we only\n   * want to rotate on the Y axis. In our AR use case, we don't want\n   * our model rotating in all axes, instead just on the Y.\n   *\n   * @param {THREE.Object3D} looker\n   * @param {THREE.Object3D} target\n   */\n  lookAtOnY(looker, target) {\n    const targetPos = new THREE.Vector3().setFromMatrixPosition(target.matrixWorld);\n    const angle = Math.atan2(targetPos.x - looker.position.x, targetPos.z - looker.position.z);\n    looker.rotation.set(0, angle, 0);\n  }\n\n};","map":{"version":3,"sources":["C:\\Users\\yonatant\\measure-app\\src\\shared\\utils.js"],"names":["THREE","opacityRemap","mat","opacity","Reticle","Object3D","constructor","xrSession","camera","loader","TextureLoader","geometry","RingGeometry","material","MeshBasicMaterial","color","applyMatrix","Matrix4","makeRotationX","Math","degToRad","ring","Mesh","PlaneBufferGeometry","makeRotationY","transparent","icon","load","texture","map","add","session","visible","update","frameOfRef","raycaster","Raycaster","setFromCamera","x","y","ray","origin","Float32Array","toArray","direction","hits","requestHitTest","length","hit","hitMatrix","fromArray","position","setFromMatrixPosition","DemoUtils","lookAtOnY","window","createLitScene","scene","Scene","light","AmbientLight","directionalLight","DirectionalLight","set","castShadow","planeGeometry","PlaneGeometry","rotateX","PI","shadowMesh","ShadowMaterial","name","receiveShadow","createCubeScene","materials","ROW_COUNT","SPREAD","HALF","i","j","k","box","BoxBufferGeometry","multiplyScalar","loadModel","objURL","mtlURL","objLoader","OBJLoader","mtlLoader","MTLLoader","setTexturePath","substr","lastIndexOf","setMaterialOptions","ignoreZeroRGBs","Promise","resolve","reject","materialCreator","preload","Object","values","setMaterials","looker","target","targetPos","Vector3","matrixWorld","angle","atan2","z","rotation"],"mappings":"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","sourcesContent":["/*\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport THREE from './third_party/three.js'\n// remaps opacity from 0 to 1\nconst opacityRemap = mat => {\n  if (mat.opacity === 0) {\n    mat.opacity = 1;\n  }\n};\n\n/**\n * The Reticle class creates an object that repeatedly calls\n * `xrSession.requestHitTest()` to render a ring along a found\n * horizontal surface.\n */\nclass Reticle extends THREE.Object3D {\n  /**\n   * @param {XRSession} xrSession\n   * @param {THREE.Camera} camera\n   */\n  constructor(xrSession, camera) {\n    super();\n\n    this.loader = new THREE.TextureLoader();\n\n    let geometry = new THREE.RingGeometry(0.1, 0.11, 24, 1);\n    let material = new THREE.MeshBasicMaterial({ color: 0xffffff });\n    // Orient the geometry so its position is flat on a horizontal surface\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(-90)));\n\n    this.ring = new THREE.Mesh(geometry, material);\n\n    geometry = new THREE.PlaneBufferGeometry(0.15, 0.15);\n    // Orient the geometry so its position is flat on a horizontal surface,\n    // as well as rotate the image so the anchor is facing the user\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(-90)));\n    geometry.applyMatrix(new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(0)));\n    material = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 0\n    });\n    this.icon = new THREE.Mesh(geometry, material);\n\n    // Load the anchor texture and apply it to our material\n    // once loaded\n    this.loader.load('../assets/Anchor.png', texture => {\n      this.icon.material.opacity = 1;\n      this.icon.material.map = texture;\n    });\n\n    this.add(this.ring);\n    this.add(this.icon);\n\n    this.session = xrSession;\n    this.visible = false;\n    this.camera = camera;\n  }\n\n  /**\n   * Fires a hit test in the middle of the screen and places the reticle\n   * upon the surface if found.\n   *\n   * @param {XRCoordinateSystem} frameOfRef\n   */\n  async update(frameOfRef) {\n    this.raycaster = this.raycaster || new THREE.Raycaster();\n    this.raycaster.setFromCamera({ x: 0, y: 0 }, this.camera);\n    const ray = this.raycaster.ray;\n\n    const origin = new Float32Array(ray.origin.toArray());\n    const direction = new Float32Array(ray.direction.toArray());\n    const hits = await this.session.requestHitTest(origin,\n                                                   direction,\n                                                   frameOfRef);\n\n    if (hits.length) {\n      const hit = hits[0];\n      const hitMatrix = new THREE.Matrix4().fromArray(hit.hitMatrix);\n\n      // Now apply the position from the hitMatrix onto our model\n      this.position.setFromMatrixPosition(hitMatrix);\n  \n      DemoUtils.lookAtOnY(this, this.camera);\n\n      this.visible = true;\n    }\n  }\n}\n\nwindow.DemoUtils = {\n  /**\n   * Creates a THREE.Scene containing lights that case shadows,\n   * and a mesh that will receive shadows.\n   *\n   * @return {THREE.Scene}\n   */\n  createLitScene() {\n    const scene = new THREE.Scene();\n\n    // The materials will render as a black mesh\n    // without lights in our scenes. Let's add an ambient light\n    // so our material can be visible, as well as a directional light\n    // for the shadow.\n    const light = new THREE.AmbientLight(0xffffff, 1);\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);\n    directionalLight.position.set(10, 15, 10);\n\n    // We want this light to cast shadow.\n    directionalLight.castShadow = true;\n\n    // Make a large plane to receive our shadows\n    const planeGeometry = new THREE.PlaneGeometry(2000, 2000);\n    // Rotate our plane to be parallel to the floor\n    planeGeometry.rotateX(-Math.PI / 2);\n\n    // Create a mesh with a shadow material, resulting in a mesh\n    // that only renders shadows once we flip the `receiveShadow` property.\n    const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({\n      color: 0x111111,\n      opacity: 0.2,\n    }));\n\n    // Give it a name so we can reference it later, and set `receiveShadow`\n    // to true so that it can render our model's shadow.\n    shadowMesh.name = 'shadowMesh';\n    shadowMesh.receiveShadow = true;\n    shadowMesh.position.y = 10000;\n\n    // Add lights and shadow material to scene.\n    scene.add(shadowMesh);\n    scene.add(light);\n    scene.add(directionalLight);\n\n    return scene;\n  },\n\n  /**\n   * Creates a THREE.Scene containing cubes all over the scene.\n   *\n   * @return {THREE.Scene}\n   */\n  createCubeScene() {\n    const scene = new THREE.Scene();\n\n    const materials = [\n      new THREE.MeshBasicMaterial({ color: 0xff0000 }),\n      new THREE.MeshBasicMaterial({ color: 0x0000ff }),\n      new THREE.MeshBasicMaterial({ color: 0x00ff00 }),\n      new THREE.MeshBasicMaterial({ color: 0xff00ff }),\n      new THREE.MeshBasicMaterial({ color: 0x00ffff }),\n      new THREE.MeshBasicMaterial({ color: 0xffff00 })\n    ];\n\n    const ROW_COUNT = 4;\n    const SPREAD = 1;\n    const HALF = ROW_COUNT / 2;\n    for (let i = 0; i < ROW_COUNT; i++) {\n      for (let j = 0; j < ROW_COUNT; j++) {\n        for (let k = 0; k < ROW_COUNT; k++) {\n          const box = new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), materials);\n          box.position.set(i - HALF, j - HALF, k - HALF);\n          box.position.multiplyScalar(SPREAD);\n          scene.add(box);\n        }\n      }\n    }\n\n    return scene;\n  },\n\n  /**\n   * Loads an OBJ model with an MTL material applied.\n   * Returns a THREE.Group object containing the mesh.\n   *\n   * @param {string} objURL\n   * @param {string} mtlURL\n   * @return {Promise<THREE.Group>}\n   */\n  loadModel(objURL, mtlURL) {\n    // OBJLoader and MTLLoader are not a part of three.js core, and\n    // must be included as separate scripts.\n    const objLoader = new THREE.OBJLoader();\n    const mtlLoader = new THREE.MTLLoader();\n\n    // Set texture path so that the loader knows where to find\n    // linked resources\n    mtlLoader.setTexturePath(mtlURL.substr(0, mtlURL.lastIndexOf('/') + 1));\n\n    // remaps ka, kd, & ks values of 0,0,0 -> 1,1,1, models from\n    // Poly benefit due to how they were encoded.\n    mtlLoader.setMaterialOptions({ ignoreZeroRGBs: true });\n\n    // OBJLoader and MTLLoader provide callback interfaces; let's\n    // return a Promise and resolve or reject based off of the asset\n    // downloading.\n    return new Promise((resolve, reject) => {\n      mtlLoader.load(mtlURL, materialCreator => {\n        // We have our material package parsed from the .mtl file.\n        // Be sure to preload it.\n        materialCreator.preload();\n\n        // Remap opacity values in the material to 1 if they're set as\n        // 0; this is another peculiarity of Poly models and some\n        // MTL materials.\n        for (let material of Object.values(materialCreator.materials)) {\n          opacityRemap(material);\n        }\n\n        // Give our OBJ loader our materials to apply it properly to the model\n        objLoader.setMaterials(materialCreator);\n\n        // Finally load our OBJ, and resolve the promise once found.\n        objLoader.load(objURL, resolve, function(){}, reject);\n      }, function(){}, reject);\n    });\n  },\n\n  /**\n   * Similar to THREE.Object3D's `lookAt` function, except we only\n   * want to rotate on the Y axis. In our AR use case, we don't want\n   * our model rotating in all axes, instead just on the Y.\n   *\n   * @param {THREE.Object3D} looker\n   * @param {THREE.Object3D} target\n   */\n  lookAtOnY(looker, target) {\n    const targetPos = new THREE.Vector3().setFromMatrixPosition(target.matrixWorld);\n\n    const angle = Math.atan2(targetPos.x - looker.position.x,\n                             targetPos.z - looker.position.z);\n    looker.rotation.set(0, angle, 0);\n  },\n};\n"]},"metadata":{},"sourceType":"module"}