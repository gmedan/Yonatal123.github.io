{"ast":null,"code":"import { Component } from 'react';\nimport threejs from './third_party/three.js';\nconst MODEL_OBJ_URL = './assets/ArcticFox_Posed.obj';\nconst MODEL_MTL_URL = './assets/ArcticFox_Posed.mtl';\nconst MODEL_SCALE = 0.1;\nexport class AR extends Component {\n  constructor(props) {\n    super(props);\n    this.onXRFrame = this.onXRFrame.bind(this);\n    this.onEnterAR = this.onEnterAR.bind(this);\n    this.onClick = this.onClick.bind(this);\n  }\n\n  async init() {\n    // The entry point of the WebXR Device API is on `navigator.xr`.\n    // We also want to ensure that `XRSession` has `requestHitTest`,\n    // indicating that the #webxr-hit-test flag is enabled.\n    if (navigator.xr && XRSession.prototype.requestHitTest) {\n      try {\n        this.device = await navigator.xr.requestDevice();\n      } catch (e) {\n        // If there are no valid XRDevice's on the system,\n        // `requestDevice()` rejects the promise. Catch our\n        // awaited promise and display message indicating there\n        // are no valid devices.\n        this.onNoXRDevice();\n        return;\n      }\n    } else {\n      // If `navigator.xr` or `XRSession.prototype.requestHitTest`\n      // does not exist, we must display a message indicating there\n      // are no valid devices.\n      this.onNoXRDevice();\n      return;\n    } // We found an XRDevice! Bind a click listener on our \"Enter AR\" button\n    // since the spec requires calling `device.requestSession()` within a\n    // user gesture.\n\n\n    document.querySelector('#enter-ar').addEventListener('click', this.onEnterAR);\n  }\n  /**\r\n   * Handle a click event on the '#enter-ar' button and attempt to\r\n   * start an XRSession.\r\n   */\n\n\n  async onEnterAR() {\n    // Now that we have an XRDevice, and are responding to a user\n    // gesture, we must create an XRPresentationContext on a\n    // canvas element.\n    const outputCanvas = document.createElement('canvas');\n    const ctx = outputCanvas.getContext('xrpresent');\n\n    try {\n      // Request a session for the XRDevice with the XRPresentationContext\n      // we just created.\n      // Note that `device.requestSession()` must be called in response to\n      // a user gesture, hence this function being a click handler.\n      const session = await this.device.requestSession({\n        outputContext: ctx,\n        environmentIntegration: true\n      }); // If `requestSession` is successful, add the canvas to the\n      // DOM since we know it will now be used.\n\n      document.body.appendChild(outputCanvas);\n      this.onSessionStarted(session);\n    } catch (e) {\n      // If `requestSession` fails, the canvas is not added, and we\n      // call our function for unsupported browsers.\n      this.onNoXRDevice();\n    }\n  }\n  /**\r\n   * Toggle on a class on the page to disable the \"Enter AR\"\r\n   * button and display the unsupported browser message.\r\n   */\n\n\n  onNoXRDevice() {\n    document.body.classList.add('unsupported');\n  }\n  /**\r\n   * Called when the XRSession has begun. Here we set up our three.js\r\n   * renderer, scene, and camera and attach our XRWebGLLayer to the\r\n   * XRSession and kick off the render loop.\r\n   */\n\n\n  async onSessionStarted(session) {\n    this.session = session; // Add the `ar` class to our body, which will hide our 2D components\n\n    document.body.classList.add('ar'); // To help with working with 3D on the web, we'll use three.js. Set up\n    // the WebGLRenderer, which handles rendering to our session's base layer.\n\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true,\n      preserveDrawingBuffer: true\n    });\n    this.renderer.autoClear = false;\n    this.gl = this.renderer.getContext(); // Ensure that the context we want to write to is compatible\n    // with our XRDevice\n\n    await this.gl.setCompatibleXRDevice(this.session.device); // Set our session's baseLayer to an XRWebGLLayer\n    // using our new renderer's context\n\n    this.session.baseLayer = new XRWebGLLayer(this.session, this.gl); // A THREE.Scene contains the scene graph for all objects in the\n    // render scene. Call our utility which gives us a THREE.Scene\n    // with a few lights and meshes already in the scene.\n\n    this.scene = DemoUtils.createLitScene(); // Use the DemoUtils.loadModel to load our OBJ and MTL. The promise\n    // resolves to a THREE.Group containing our mesh information.\n    // Dont await this promise, as we want to start the rendering\n    // process before this finishes.\n\n    DemoUtils.loadModel(MODEL_OBJ_URL, MODEL_MTL_URL).then(model => {\n      this.model = model; // Every model is different -- you may have to adjust the scale\n      // of a model depending on the use.\n\n      this.model.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);\n    }); // We'll update the camera matrices directly from API, so\n    // disable matrix auto updates so three.js doesn't attempt\n    // to handle the matrices independently.\n\n    this.camera = new THREE.PerspectiveCamera();\n    this.camera.matrixAutoUpdate = false; // Add a Reticle object, which will help us find surfaces by drawing\n    // a ring shape onto found surfaces. See source code\n    // of Reticle in shared/utils.js for more details.\n\n    this.reticle = new Reticle(this.session, this.camera);\n    this.scene.add(this.reticle);\n    this.frameOfRef = await this.session.requestFrameOfReference('eye-level');\n    this.session.requestAnimationFrame(this.onXRFrame);\n    window.addEventListener('click', this.onClick);\n  }\n  /**\r\n   * Called on the XRSession's requestAnimationFrame.\r\n   * Called with the time and XRPresentationFrame.\r\n   */\n\n\n  onXRFrame(time, frame) {\n    let session = frame.session;\n    let pose = frame.getDevicePose(this.frameOfRef); // Update the reticle's position\n\n    this.reticle.update(this.frameOfRef); // If the reticle has found a hit (is visible) and we have\n    // not yet marked our app as stabilized, do so\n\n    if (this.reticle.visible && !this.stabilized) {\n      this.stabilized = true;\n      document.body.classList.add('stabilized');\n    } // Queue up the next frame\n\n\n    session.requestAnimationFrame(this.onXRFrame); // Bind the framebuffer to our baseLayer's framebuffer\n\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.baseLayer.framebuffer);\n\n    if (pose) {\n      // Our XRFrame has an array of views. In the VR case, we'll have\n      // two views, one for each eye. In mobile AR, however, we only\n      // have one view.\n      for (let view of frame.views) {\n        const viewport = session.baseLayer.getViewport(view);\n        this.renderer.setSize(viewport.width, viewport.height); // Set the view matrix and projection matrix from XRDevicePose\n        // and XRView onto our THREE.Camera.\n\n        this.camera.projectionMatrix.fromArray(view.projectionMatrix);\n        const viewMatrix = new THREE.Matrix4().fromArray(pose.getViewMatrix(view));\n        this.camera.matrix.getInverse(viewMatrix);\n        this.camera.updateMatrixWorld(true); // Render our scene with our THREE.WebGLRenderer\n\n        this.renderer.render(this.scene, this.camera);\n      }\n    }\n  }\n  /**\r\n   * This method is called when tapping on the page once an XRSession\r\n   * has started. We're going to be firing a ray from the center of\r\n   * the screen, and if a hit is found, use it to place our object\r\n   * at the point of collision.\r\n   */\n\n\n  async onClick(e) {\n    // If our model is not yet loaded, abort\n    if (!this.model) {\n      return;\n    } // We're going to be firing a ray from the center of the screen.\n    // The requestHitTest function takes an x and y coordinate in\n    // Normalized Device Coordinates, where the upper left is (-1, 1)\n    // and the bottom right is (1, -1). This makes (0, 0) our center.\n\n\n    const x = 0;\n    const y = 0; // Create a THREE.Raycaster if one doesn't already exist,\n    // and use it to generate an origin and direction from\n    // our camera (device) using the tap coordinates.\n    // Learn more about THREE.Raycaster:\n    // https://threejs.org/docs/#api/core/Raycaster\n\n    this.raycaster = this.raycaster || new THREE.Raycaster();\n    this.raycaster.setFromCamera({\n      x,\n      y\n    }, this.camera);\n    const ray = this.raycaster.ray; // Fire the hit test to see if our ray collides with a real\n    // surface. Note that we must turn our THREE.Vector3 origin and\n    // direction into an array of x, y, and z values. The proposal\n    // for `XRSession.prototype.requestHitTest` can be found here:\n    // https://github.com/immersive-web/hit-test\n\n    const origin = new Float32Array(ray.origin.toArray());\n    const direction = new Float32Array(ray.direction.toArray());\n    const hits = await this.session.requestHitTest(origin, direction, this.frameOfRef); // If we found at least one hit...\n\n    if (hits.length) {\n      // We can have multiple collisions per hit test. Let's just take the\n      // first hit, the nearest, for now.\n      const hit = hits[0]; // Our XRHitResult object has one property, `hitMatrix`, a\n      // Float32Array(16) representing a 4x4 Matrix encoding position where\n      // the ray hit an object, and the orientation has a Y-axis that corresponds\n      // with the normal of the object at that location.\n      // Turn this matrix into a THREE.Matrix4().\n\n      const hitMatrix = new THREE.Matrix4().fromArray(hit.hitMatrix); // Now apply the position from the hitMatrix onto our model.\n\n      this.model.position.setFromMatrixPosition(hitMatrix); // Rather than using the rotation encoded by the `modelMatrix`,\n      // rotate the model to face the camera. Use this utility to\n      // rotate the model only on the Y axis.\n\n      DemoUtils.lookAtOnY(this.model, this.camera); // Ensure our model has been added to the scene.\n\n      this.scene.add(this.model);\n    }\n  }\n\n  render() {\n    if (this.props.show) {\n      this.init();\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["C:\\Users\\yonatant\\measure-app\\src\\AR.js"],"names":["Component","threejs","MODEL_OBJ_URL","MODEL_MTL_URL","MODEL_SCALE","AR","constructor","props","onXRFrame","bind","onEnterAR","onClick","init","navigator","xr","XRSession","prototype","requestHitTest","device","requestDevice","e","onNoXRDevice","document","querySelector","addEventListener","outputCanvas","createElement","ctx","getContext","session","requestSession","outputContext","environmentIntegration","body","appendChild","onSessionStarted","classList","add","renderer","THREE","WebGLRenderer","alpha","preserveDrawingBuffer","autoClear","gl","setCompatibleXRDevice","baseLayer","XRWebGLLayer","scene","DemoUtils","createLitScene","loadModel","then","model","scale","set","camera","PerspectiveCamera","matrixAutoUpdate","reticle","Reticle","frameOfRef","requestFrameOfReference","requestAnimationFrame","window","time","frame","pose","getDevicePose","update","visible","stabilized","bindFramebuffer","FRAMEBUFFER","framebuffer","view","views","viewport","getViewport","setSize","width","height","projectionMatrix","fromArray","viewMatrix","Matrix4","getViewMatrix","matrix","getInverse","updateMatrixWorld","render","x","y","raycaster","Raycaster","setFromCamera","ray","origin","Float32Array","toArray","direction","hits","length","hit","hitMatrix","position","setFromMatrixPosition","lookAtOnY","show"],"mappings":"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","sourcesContent":["import { Component } from 'react';\r\nimport threejs from './third_party/three.js'\r\n\r\nconst MODEL_OBJ_URL = './assets/ArcticFox_Posed.obj';\r\nconst MODEL_MTL_URL = './assets/ArcticFox_Posed.mtl';\r\nconst MODEL_SCALE = 0.1;\r\n\r\nexport class AR extends Component{\r\n    constructor(props){\r\n        super(props)\r\n        this.onXRFrame = this.onXRFrame.bind(this);\r\n        this.onEnterAR = this.onEnterAR.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n     }\r\n\r\n     async init() {\r\n        // The entry point of the WebXR Device API is on `navigator.xr`.\r\n        // We also want to ensure that `XRSession` has `requestHitTest`,\r\n        // indicating that the #webxr-hit-test flag is enabled.\r\n        if (navigator.xr && XRSession.prototype.requestHitTest) {\r\n          try {\r\n            this.device = await navigator.xr.requestDevice();\r\n          } catch (e) {\r\n            // If there are no valid XRDevice's on the system,\r\n            // `requestDevice()` rejects the promise. Catch our\r\n            // awaited promise and display message indicating there\r\n            // are no valid devices.\r\n            this.onNoXRDevice();\r\n            return;\r\n          }\r\n        } else {\r\n          // If `navigator.xr` or `XRSession.prototype.requestHitTest`\r\n          // does not exist, we must display a message indicating there\r\n          // are no valid devices.\r\n          this.onNoXRDevice();\r\n          return;\r\n        }\r\n    \r\n        // We found an XRDevice! Bind a click listener on our \"Enter AR\" button\r\n        // since the spec requires calling `device.requestSession()` within a\r\n        // user gesture.\r\n        document.querySelector('#enter-ar').addEventListener('click', this.onEnterAR);\r\n      }\r\n    \r\n      /**\r\n       * Handle a click event on the '#enter-ar' button and attempt to\r\n       * start an XRSession.\r\n       */\r\n      async onEnterAR() {\r\n        // Now that we have an XRDevice, and are responding to a user\r\n        // gesture, we must create an XRPresentationContext on a\r\n        // canvas element.\r\n        const outputCanvas = document.createElement('canvas');\r\n        const ctx = outputCanvas.getContext('xrpresent');\r\n    \r\n        try {\r\n          // Request a session for the XRDevice with the XRPresentationContext\r\n          // we just created.\r\n          // Note that `device.requestSession()` must be called in response to\r\n          // a user gesture, hence this function being a click handler.\r\n          const session = await this.device.requestSession({\r\n            outputContext: ctx,\r\n            environmentIntegration: true,\r\n          });\r\n    \r\n          // If `requestSession` is successful, add the canvas to the\r\n          // DOM since we know it will now be used.\r\n          document.body.appendChild(outputCanvas);\r\n          this.onSessionStarted(session)\r\n        } catch (e) {\r\n          // If `requestSession` fails, the canvas is not added, and we\r\n          // call our function for unsupported browsers.\r\n          this.onNoXRDevice();\r\n        }\r\n      }\r\n    \r\n      /**\r\n       * Toggle on a class on the page to disable the \"Enter AR\"\r\n       * button and display the unsupported browser message.\r\n       */\r\n      onNoXRDevice() {\r\n        document.body.classList.add('unsupported');\r\n      }\r\n    \r\n      /**\r\n       * Called when the XRSession has begun. Here we set up our three.js\r\n       * renderer, scene, and camera and attach our XRWebGLLayer to the\r\n       * XRSession and kick off the render loop.\r\n       */\r\n      async onSessionStarted(session) {\r\n        this.session = session;\r\n    \r\n        // Add the `ar` class to our body, which will hide our 2D components\r\n        document.body.classList.add('ar');\r\n    \r\n        // To help with working with 3D on the web, we'll use three.js. Set up\r\n        // the WebGLRenderer, which handles rendering to our session's base layer.\r\n        this.renderer = new THREE.WebGLRenderer({\r\n          alpha: true,\r\n          preserveDrawingBuffer: true,\r\n        });\r\n        this.renderer.autoClear = false;\r\n    \r\n        this.gl = this.renderer.getContext();\r\n    \r\n        // Ensure that the context we want to write to is compatible\r\n        // with our XRDevice\r\n        await this.gl.setCompatibleXRDevice(this.session.device);\r\n    \r\n        // Set our session's baseLayer to an XRWebGLLayer\r\n        // using our new renderer's context\r\n        this.session.baseLayer = new XRWebGLLayer(this.session, this.gl);\r\n    \r\n        // A THREE.Scene contains the scene graph for all objects in the\r\n        // render scene. Call our utility which gives us a THREE.Scene\r\n        // with a few lights and meshes already in the scene.\r\n        this.scene = DemoUtils.createLitScene();\r\n    \r\n        // Use the DemoUtils.loadModel to load our OBJ and MTL. The promise\r\n        // resolves to a THREE.Group containing our mesh information.\r\n        // Dont await this promise, as we want to start the rendering\r\n        // process before this finishes.\r\n        DemoUtils.loadModel(MODEL_OBJ_URL, MODEL_MTL_URL).then(model => {\r\n          this.model = model;\r\n    \r\n          // Every model is different -- you may have to adjust the scale\r\n          // of a model depending on the use.\r\n          this.model.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);\r\n        });\r\n    \r\n    \r\n        // We'll update the camera matrices directly from API, so\r\n        // disable matrix auto updates so three.js doesn't attempt\r\n        // to handle the matrices independently.\r\n        this.camera = new THREE.PerspectiveCamera();\r\n        this.camera.matrixAutoUpdate = false;\r\n    \r\n        // Add a Reticle object, which will help us find surfaces by drawing\r\n        // a ring shape onto found surfaces. See source code\r\n        // of Reticle in shared/utils.js for more details.\r\n        this.reticle = new Reticle(this.session, this.camera);\r\n        this.scene.add(this.reticle);\r\n    \r\n        this.frameOfRef = await this.session.requestFrameOfReference('eye-level');\r\n        this.session.requestAnimationFrame(this.onXRFrame);\r\n    \r\n        window.addEventListener('click', this.onClick);\r\n      }\r\n    \r\n      /**\r\n       * Called on the XRSession's requestAnimationFrame.\r\n       * Called with the time and XRPresentationFrame.\r\n       */\r\n      onXRFrame(time, frame) {\r\n        let session = frame.session;\r\n        let pose = frame.getDevicePose(this.frameOfRef);\r\n    \r\n        // Update the reticle's position\r\n        this.reticle.update(this.frameOfRef);\r\n    \r\n        // If the reticle has found a hit (is visible) and we have\r\n        // not yet marked our app as stabilized, do so\r\n        if (this.reticle.visible && !this.stabilized) {\r\n          this.stabilized = true;\r\n          document.body.classList.add('stabilized');\r\n        }\r\n    \r\n        // Queue up the next frame\r\n        session.requestAnimationFrame(this.onXRFrame);\r\n    \r\n        // Bind the framebuffer to our baseLayer's framebuffer\r\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.baseLayer.framebuffer);\r\n    \r\n        if (pose) {\r\n          // Our XRFrame has an array of views. In the VR case, we'll have\r\n          // two views, one for each eye. In mobile AR, however, we only\r\n          // have one view.\r\n          for (let view of frame.views) {\r\n            const viewport = session.baseLayer.getViewport(view);\r\n            this.renderer.setSize(viewport.width, viewport.height);\r\n    \r\n            // Set the view matrix and projection matrix from XRDevicePose\r\n            // and XRView onto our THREE.Camera.\r\n            this.camera.projectionMatrix.fromArray(view.projectionMatrix);\r\n            const viewMatrix = new THREE.Matrix4().fromArray(pose.getViewMatrix(view));\r\n            this.camera.matrix.getInverse(viewMatrix);\r\n            this.camera.updateMatrixWorld(true);\r\n    \r\n            // Render our scene with our THREE.WebGLRenderer\r\n            this.renderer.render(this.scene, this.camera);\r\n          }\r\n        }\r\n      }\r\n    \r\n      /**\r\n       * This method is called when tapping on the page once an XRSession\r\n       * has started. We're going to be firing a ray from the center of\r\n       * the screen, and if a hit is found, use it to place our object\r\n       * at the point of collision.\r\n       */\r\n      async onClick(e) {\r\n        // If our model is not yet loaded, abort\r\n        if (!this.model) {\r\n          return;\r\n        }\r\n    \r\n        // We're going to be firing a ray from the center of the screen.\r\n        // The requestHitTest function takes an x and y coordinate in\r\n        // Normalized Device Coordinates, where the upper left is (-1, 1)\r\n        // and the bottom right is (1, -1). This makes (0, 0) our center.\r\n        const x = 0;\r\n        const y = 0;\r\n    \r\n        // Create a THREE.Raycaster if one doesn't already exist,\r\n        // and use it to generate an origin and direction from\r\n        // our camera (device) using the tap coordinates.\r\n        // Learn more about THREE.Raycaster:\r\n        // https://threejs.org/docs/#api/core/Raycaster\r\n        this.raycaster = this.raycaster || new THREE.Raycaster();\r\n        this.raycaster.setFromCamera({ x, y }, this.camera);\r\n        const ray = this.raycaster.ray;\r\n    \r\n        // Fire the hit test to see if our ray collides with a real\r\n        // surface. Note that we must turn our THREE.Vector3 origin and\r\n        // direction into an array of x, y, and z values. The proposal\r\n        // for `XRSession.prototype.requestHitTest` can be found here:\r\n        // https://github.com/immersive-web/hit-test\r\n        const origin = new Float32Array(ray.origin.toArray());\r\n        const direction = new Float32Array(ray.direction.toArray());\r\n        const hits = await this.session.requestHitTest(origin,\r\n                                                       direction,\r\n                                                       this.frameOfRef);\r\n    \r\n        // If we found at least one hit...\r\n        if (hits.length) {\r\n          // We can have multiple collisions per hit test. Let's just take the\r\n          // first hit, the nearest, for now.\r\n          const hit = hits[0];\r\n    \r\n          // Our XRHitResult object has one property, `hitMatrix`, a\r\n          // Float32Array(16) representing a 4x4 Matrix encoding position where\r\n          // the ray hit an object, and the orientation has a Y-axis that corresponds\r\n          // with the normal of the object at that location.\r\n          // Turn this matrix into a THREE.Matrix4().\r\n          const hitMatrix = new THREE.Matrix4().fromArray(hit.hitMatrix);\r\n    \r\n          // Now apply the position from the hitMatrix onto our model.\r\n          this.model.position.setFromMatrixPosition(hitMatrix);\r\n    \r\n          // Rather than using the rotation encoded by the `modelMatrix`,\r\n          // rotate the model to face the camera. Use this utility to\r\n          // rotate the model only on the Y axis.\r\n          DemoUtils.lookAtOnY(this.model, this.camera);\r\n        \r\n          // Ensure our model has been added to the scene.\r\n          this.scene.add(this.model);\r\n        }\r\n    }\r\n\r\n    render(){\r\n        if(this.props.show)\r\n        {\r\n            this.init();\r\n        }\r\n        return null;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}